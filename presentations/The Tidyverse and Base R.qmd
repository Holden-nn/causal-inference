---
title: "The Tidyverse and Base R"
subtitle: "MKTG 585R Quantitative Marketing Pre-PhD Seminar"
highlight-style: github
format: 
  revealjs:
    theme: simple
    scrollable: true
    slide-number: true
    self-contained: true
execute:
  echo: true
  output: true
  warning: true
---

# Summarize Data

```{r}
#| echo: false
#| warning: false
library(tidyverse)
customer_data <- read_csv(here::here("Data", "customer_data.csv"))
store_transactions <- read_csv(here::here("Data", "store_transactions.csv"))
crm_data <- read_csv(here::here("Data", "customer_data.csv")) |> 
  left_join(read_csv(here::here("Data", "store_transactions.csv")), by = "customer_id")
crm_list <- list(customer_data, store_transactions)
```

## Summarize Discrete Data

The go-to statistic for a discrete variable is a **count**.

```{r}
customer_data |> 
  count(region)
```

## Summarize Continuous Data

The obvious statistic for a continuous variable is a **mean**.

```{r}
customer_data |>
  summarize(avg_income = mean(income))
```

Note that `summarize()` is a more general version of `count()`.

We can also compute the **mode**, **median**, **variance**, **standard deviation**, **minimum**, **maximum**, **sum**, etc.

## Visualize Data

{ggplot2} provides a consistent **grammar of graphics** built with **layers**.

1. Data – Data to visualize.
2. Aesthetics – Mapping graphical elements to data.
3. Geometry – Or "geom," the graphic representing the data.
4. Facets, Labels, Scales, etc.

## Visualize Discrete Data

Plot our first summary (note how `+` is different from `|>`).

```{r}
customer_data |> 
  count(region, college_degree) |> 
  ggplot(aes(x = region, y = n, fill = college_degree)) +
  geom_col(position = "fill")
```

## Facets

Facets allow us to visualize by another discrete variable. For example, is this relationship different depending on `gender`?

```{r}
customer_data |> 
  count(region, college_degree, gender) |> 
  ggplot(aes(x = region, y = n, fill = college_degree)) +
  geom_col(position = "fill") +
  facet_wrap(~ gender)
```

## Labels and Scales

It's no longer a count on the y-axis. Let's change the labels.

```{r eval=FALSE}
customer_data |> 
  count(region, college_degree, gender) |> 
  ggplot(aes(x = region, y = n, fill = college_degree)) +
  geom_col(position = "fill") +
  facet_wrap(~ gender) +
  labs(
    title = "Proportion of Customers with College Degrees by Region and Gender",
    subtitle = "Based on 10,531 Customers in the CRM Database",
    x = "Region",
    y = "Proportion"
  )
```

---

```{r echo=FALSE}
customer_data |> 
  count(region, college_degree, gender) |> 
  ggplot(aes(x = region, y = n, fill = college_degree)) +
  geom_col(position = "fill") +
  facet_wrap(~ gender) +
  labs(
    title = "Proportion of Customers with College Degrees by Region and Gender",
    subtitle = "Based on 10,531 Customers in the CRM Database",
    x = "Region",
    y = "Proportion"
  )
```

---

What about the legend? And these *colors*?

```{r eval=FALSE}
customer_data |> 
  count(region, college_degree, gender) |> 
  ggplot(aes(x = region, y = n, fill = college_degree)) +
  geom_col(position = "fill") +
  facet_wrap(~ gender) +
  labs(
    title = "Proportion of Customers with College Degrees by Region and Gender",
    subtitle = "Based on 10,531 Customers in the CRM Database",
    x = "Region",
    y = "Proportion"
  ) +
  scale_fill_manual(
    name = "College Degree",
    values = c("royalblue", "darkblue")
  )
```

---

```{r echo=FALSE}
customer_data |> 
  count(region, college_degree, gender) |> 
  ggplot(aes(x = region, y = n, fill = college_degree)) +
  geom_col(position = "fill") +
  facet_wrap(~ gender) +
  labs(
    title = "Proportion of Customers with College Degrees by Region and Gender",
    subtitle = "Based on 10,531 Customers in the CRM Database",
    x = "Region",
    y = "Proportion"
  ) +
  scale_fill_manual(
    name = "College Degree",
    values = c("royalblue", "darkblue")
  )
```

## Visualize Continuous Data

Let’s plot the **distribution** of income.

```{r}
customer_data |> 
  ggplot(aes(x = income)) +
  geom_histogram()
```

---

Visualize the relationship between `income` and `credit`.

```{r}
customer_data |> 
  ggplot(aes(x = income, y = credit)) +
  geom_point()
```

---

Visualize the relationship between `star_rating` and `income`.

```{r}
customer_data |> 
  ggplot(aes(x = star_rating, y = income)) +
  geom_point()
```

---

What do we do if there is **overplotting**? There’s a geom for that.

```{r eval=FALSE}
customer_data |> 
  drop_na(star_rating) |> 
  ggplot(aes(x = star_rating, y = income)) +
  geom_jitter(size = 3, alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(~ region) +
  labs(
    title = "Relationship Between Star Rating and Income by Region",
    x = "Star Rating",
    y = "Income"
  )
```

---

```{r echo=FALSE}
customer_data |> 
  drop_na(star_rating) |> 
  ggplot(aes(x = star_rating, y = income)) +
  geom_jitter(size = 3, alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(~ region) +
  labs(
    title = "Relationship Between Star Rating and Income by Region",
    x = "Star Rating",
    y = "Income"
  )
```

## Summarize Continuous and Discrete Data

**Grouped summaries** provide a powerful solution for computing continuous statistics by discrete categories.

```{r}
customer_data |>
  group_by(gender) |>
  summarize(
    n = n(),
    avg_income = mean(income),
    avg_credit = mean(credit)
  )
```

---

Note how the `group_by()` function is a lot like the `facet_wrap()`, it filters the data by each category in the discrete group variable.

`count()` is a **wrapper** around a grouped summary using `n()`.

---

```{r}
customer_data |>
  group_by(gender) |>
  summarize(
    n = n()
  )

customer_data |>
  count(gender)
```

---

We can group by more than one discrete variable.

```{r}
customer_data |>
  group_by(gender, region) |>
  summarize(
    n = n(),
    avg_income = mean(income),
    avg_credit = mean(credit)
  ) |> 
  arrange(desc(avg_income))
```

---

We can also use `slice_*()` functions along with `group_by()`.

```{r}
customer_data |>
  group_by(gender, region) |>
  slice_max(income, n = 3)
```

## Visualize Continuous and Discrete Data

Just like there are geoms for visualizing continuous or discrete data, there are geoms for visualizing the relationship between continuous and discrete data.

```{r}
customer_data |> 
  ggplot(aes(x = income, y = gender)) +
  geom_boxplot()
```

---

```{r}
customer_data |> 
  ggplot(aes(x = income, fill = gender)) +
  geom_density(alpha = 0.5)
```

# Tidy Data

## Tidy Data and the *Tidy*verse

**Tidy data** is defined as follows:

- Each observation has its own row.
- Each variable has its own column.
- Each value has its own cell.

This may seem obvious or simple, but this common philosophy is at the heart of the *tidy*verse. It also means we will often prefer **longer** datasets to **wider** datasets and {tidyr} will help us move between the two.

---

<center>
![](../Figures/wide_long.png){width=750px}
</center>

## Pivot Longer

The most common problem with **messy data** is when column names are really values.

```{r}
crm_data |> 
  select(region, customer_id, contains("2018"))
```

---

When column names are really values, the data frame ends up being wider than it should be. Use `pivot_longer()` to pivot the data frame longer by **turning column names into values**.

```{r}
crm_long <- crm_data |>
  select(region, customer_id, contains("2018")) |> 
  pivot_longer(
    -c(region, customer_id),
    names_to = "month_year",
    values_to = "transactions"
  )
```

---

Note how much *longer* the data frame is and *why*.

```{r}
crm_long
```

---

Now summarizing the transactions for 2018 by region is trivial.

```{r}
crm_long |> 
  group_by(region) |> 
  summarize(
    total_transactions = sum(transactions),
    avg_transactions = mean(transactions)
  )
```

## Pivot Wider

If the data has the opposite problem and has values that should really be column names, use `pivot_wider()` to pivot the data frame wider by **turning values into column names**.

```{r}
crm_long |> 
  pivot_wider(
    names_from = month_year,
    values_from = transactions
  )
```

---

<center>
![](../Figures/pivot.gif){width=500px}
</center>

## Separate Columns

If two (or more) values are in one column, `separate()` the values into two (or more) columns.

```{r}
crm_long <- crm_long |>
  separate(month_year, c("month", "year"), sep = "_")

crm_long
```

---

Now we can summarize the transactions for 2018 by month *and* region.

```{r}
crm_long |> 
  group_by(month, region) |> 
  summarize(
    total_transactions = sum(transactions),
    avg_transactions = mean(transactions)
  ) |> 
  arrange(desc(avg_transactions))
```

## Unite Columns

When two (or more) values should be in one column, `unite()` the values into one column.

```{r}
crm_long |>
  unite("month_year", c(month, year), sep = "_")
```

## Data Classes and Types

We've been using **data frames** (technically **tibbles**, the tidyverse data frame). A data frame is composed of columns called **vectors**. Both data frames and vectors are classes of data.

Each vector has a *single* data type. Data types include **double** (i.e., numeric), **integer**, **date**, **character**, and **factor**. Discrete data is often a factor, which includes both integer `levels` and character `labels`.

If we try to mix data types in a vector, it will pick the easiest one to satisfy.

## Coercion

Sometimes we need to **coerce** a data class or type, for example `as_tibble()`. We can similarly coerce data types with `as.*()` functions (e.g., `as.numeric()` and `as.character()`).

However, coercing dates is very tricky (see supplementary material for details) while we often want to coerce factors using the `fct_*()` functions.

# Base R

## More Data Classes

A **list** is like a vector where each entry in the vector can be its own data class. It is the most *general* data class in R.

- A vector is a list of values all of the same data type.
- A data frame is a list of vectors with the same length.
- We could have a list of vectors, data frames, and lists.

We also have **matrices**, the two-dimensional extension of vectors, and **arrays**, matrices with more than two dimensions.

## Indexing

Indexing (subsetting, selecting) is about picking part of an object.

```{r}
crm_data$gender[1]
```

```{r}
crm_data[10:15, 3:4]
```

---

```{r}
crm_data[1:10, c("birth_year", "gender")]
```

---

```{r}
crm_data[, -4]
```

---

```{r}
crm_list[[1]]
```

## Summary, Length, and Structure

The `summary()` function is a **generic function** that summarizes an object in a way that is (usually) appropriate for the type of data.

```{r}
summary(customer_data$income)
summary(crm_list)
```

Keep tabs on the dimensions of an object using `length()` and (more generally) `str()`.

## Missing Values

R treats missing values in a particular way: `NA`.

```{r}
mean(customer_data$star_rating, na.rm = TRUE)
```

Or the tidyverse way:

```{r}
customer_data |> 
  drop_na(star_rating) |> 
  summarize(star_mean = mean(star_rating))
```

## Plot

The `plot()` function is another generic function that handles an object in a way that is (usually) appropriate for the type of data.

```{r}
plot(customer_data$income, customer_data$credit)
```

---

There are other flavors of `plot()`.

```{r}
hist(customer_data$income)
```

---

Base R plotting can be deceptively straightforward. Using {ggplot2} can feel very verbose in comparison, but it's also more explicit. The actual plot that's created is stored very differently. While {ggplot2} adds layers onto a PNG, you can layer different `plot()`-adjacent functions to draw ontop of the previous plot.

## For Loops

If you have to copy and paste something more than twice you should consider coding the iteration. This is usually in the form of a **for loop** (though you don't have to write it, see `apply()` and `map()`).

```{r}
empty_vector <- vector(mode = "double", length = 7)
for (i in seq_along(empty_vector)) {
  empty_vector[i] <- 1 + i
}

empty_vector
```

## Conditional Statements

Sometimes you want code to run only when certain conditions are met. To do this, use **conditional statements**. Note that these are a separate idea from for loops, but a for loop can be a great place to use them!

```{r}
empty_vector <- vector(mode = "double", length = 7)
for (i in seq_along(empty_vector)) {
  if (i == 1) {
    empty_vector[i] <- 1
  } else {
    empty_vector[i] <- 1 + empty_vector[i - 1]
  }
}

empty_vector
```

## Functions

While a for loop is a powerful way to code an iteration and conditional statements give us even more flexibility, we might still need to copy and paste more than twice. What we often want is a **function**.

```{r}
times_y <- function(x, y = 2) {
  x * y
}

times_y(2)

times_y(x = 2, y = 4)
```

---

A few things to note:

- The arguments can include defaults.
- Variables defined inside a function aren't *automatically* accessible outside and vice versa.
- The last line is automatically returned, or we can use `return()` to get back a specific output.
- Since a function has its own environment, debugging is trickier. Call `debugonce()` and then call the function.

## Assignment 1

Prepare a five-to-ten minute presentation on the paper you've selected and read. Note that if you want include links the notation is `[link name](URL)` and an image is `![alt text](file path)`. You can also use `$`s around math or `$$`s around blocks of math.

---

Finally, if you modify the header you can specify where any figures you *create* will be saved (this will be especially important in future assignments).

```
---
title: "Paper Title"
format: revealjs
knitr:
  opts_chunk:
    fig.path: "../Figures/"
---
```

The name of the figures will match the label of the code block in which it was created (i.e., `#| label: fig-ppd`).

